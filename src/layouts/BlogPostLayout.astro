---
import BaseLayout from './BaseLayout.astro';
import CoupangBanner from '../components/CoupangBanner.astro';
import AdSlot from '../components/AdSlot.astro';
import RelatedPosts from '../components/RelatedPosts.astro';
import NewsletterCTA from '../components/NewsletterCTA.astro';

interface FaqItem {
  q: string;
  a: string;
}

interface Props {
  frontmatter: {
    title: string;
    description: string;
    pubDate: string;
    updatedDate?: string;
    author: string;
    category: string;
    tags: string[];
    heroImage?: string;
    coupangLinks?: { title: string; url: string; imageUrl?: string }[];
    faq?: FaqItem[];
  };
}

const { frontmatter } = Astro.props;
const {
  title,
  description,
  pubDate,
  updatedDate,
  author,
  category,
  tags,
  heroImage,
  coupangLinks,
  faq,
} = frontmatter;

const pubDateObj = new Date(pubDate);
const formattedDate = pubDateObj.toLocaleDateString('ko-KR', {
  year: 'numeric',
  month: 'long',
  day: 'numeric',
});

// Category labels
const categoryLabel: Record<string, string> = {
  lifestyle: '라이프스타일',
  finance: '금융',
  health: '건강',
  education: '교육',
  travel: '여행',
};
const catLabel = category ? categoryLabel[category.toLowerCase()] || category : 'Blog';

// JSON-LD structured data for SEO
const canonicalUrl = Astro.url.href;
const imageObj = heroImage ? { url: heroImage, alt: title } : undefined;
const jsonLd = {
  '@context': 'https://schema.org',
  '@type': 'Article',
  headline: title,
  description: description,
  datePublished: pubDateObj.toISOString(),
  ...(updatedDate && { dateModified: new Date(updatedDate).toISOString() }),
  author: {
    '@type': 'Person',
    name: author,
  },
  publisher: {
    '@type': 'Organization',
    name: 'LifeFlow',
    url: 'https://life-revenue-blog.vercel.app',
    logo: {
      '@type': 'ImageObject',
      url: 'https://life-revenue-blog.vercel.app/favicon.svg',
    },
  },
  mainEntityOfPage: {
    '@type': 'WebPage',
    '@id': canonicalUrl,
  },
  keywords: tags.join(', '),
  ...(imageObj && {
    image: {
      '@type': 'ImageObject',
      url: imageObj.url,
      alt: imageObj.alt,
    },
  }),
};

// BreadcrumbList schema for navigation hierarchy
const breadcrumbLd = {
  '@context': 'https://schema.org',
  '@type': 'BreadcrumbList',
  itemListElement: [
    {
      '@type': 'ListItem',
      position: 1,
      name: '홈',
      item: 'https://life-revenue-blog.vercel.app/',
    },
    {
      '@type': 'ListItem',
      position: 2,
      name: '블로그',
      item: 'https://life-revenue-blog.vercel.app/blog/',
    },
    {
      '@type': 'ListItem',
      position: 3,
      name: catLabel,
      item: `https://life-revenue-blog.vercel.app/blog/${category.toLowerCase()}/`,
    },
    {
      '@type': 'ListItem',
      position: 4,
      name: title,
    },
  ],
};

// FAQPage JSON-LD (구글 FAQ 리치 스니펫)
const faqLd = faq && faq.length > 0 ? {
  '@context': 'https://schema.org',
  '@type': 'FAQPage',
  mainEntity: faq.map(item => ({
    '@type': 'Question',
    name: item.q,
    acceptedAnswer: {
      '@type': 'Answer',
      text: item.a,
    },
  })),
} : null;

// Get slug from URL
const currentSlug = Astro.url.pathname.split('/').filter(Boolean).pop() || '';

// Get all posts for prev/next navigation
const allPostModules = import.meta.glob('../blog/**/*.md', { eager: true });
const allPosts = Object.entries(allPostModules)
  .map(([path, post]: [string, any]) => {
    const slug = path
      .replace('../blog/', '')
      .replace('.md', '')
      .split('/')
      .slice(-1)[0];
    return {
      slug,
      title: post.frontmatter.title,
      pubDate: post.frontmatter.pubDate,
    };
  })
  .sort((a, b) => new Date(a.pubDate).getTime() - new Date(b.pubDate).getTime());

const currentIndex = allPosts.findIndex((p) => p.slug === currentSlug);
const prevPost = currentIndex > 0 ? allPosts[currentIndex - 1] : null;
const nextPost = currentIndex < allPosts.length - 1 ? allPosts[currentIndex + 1] : null;
---

<BaseLayout title={title} description={description} image={imageObj?.url}>
  <!-- JSON-LD Structured Data -->
  <script type="application/ld+json" set:html={JSON.stringify(jsonLd)} />
  <script type="application/ld+json" set:html={JSON.stringify(breadcrumbLd)} />
  {faqLd && <script type="application/ld+json" set:html={JSON.stringify(faqLd)} />}

  <article class="blog-post">
    <!-- Breadcrumb Navigation -->
    <nav class="breadcrumb" aria-label="breadcrumb">
      <ol>
        <li><a href="/">홈</a></li>
        <li><a href="/blog/">블로그</a></li>
        <li><a href={`/blog/${category.toLowerCase()}/`}>{catLabel}</a></li>
        <li aria-current="page">{title}</li>
      </ol>
    </nav>

    <header class="post-header">
      <div class="post-meta">
        <span class="post-category" data-cat={category.toLowerCase()}>{category}</span>
        <time datetime={pubDateObj.toISOString()}>{formattedDate}</time>
        <span class="post-reading-time">읽기 약 3분</span>
        {
          updatedDate && (
            <span class="post-updated">
              (수정:{' '}
              {new Date(updatedDate).toLocaleDateString('ko-KR', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
              })}
              )
            </span>
          )
        }
      </div>
      <h1>{title}</h1>
      <p class="post-description">{description}</p>
      <div class="post-tags">
        {tags.map((tag) => (
          <a href={`/blog/tags/${encodeURIComponent(tag)}/`} class="tag">#{tag}</a>
        ))}
      </div>

      <!-- Social Share Buttons -->
      <div class="share-buttons">
        <span class="share-label">공유하기</span>
        <a
          href={`https://twitter.com/intent/tweet?text=${encodeURIComponent(title)}&url=${encodeURIComponent(canonicalUrl)}`}
          target="_blank"
          rel="noopener noreferrer"
          class="share-btn share-twitter"
          aria-label="트위터에 공유"
          title="트위터에 공유"
        >
          <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
          </svg>
        </a>
        <a
          href={`https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(canonicalUrl)}`}
          target="_blank"
          rel="noopener noreferrer"
          class="share-btn share-facebook"
          aria-label="페이스북에 공유"
          title="페이스북에 공유"
        >
          <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
            <path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/>
          </svg>
        </a>
        <a
          href={`https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(canonicalUrl)}`}
          target="_blank"
          rel="noopener noreferrer"
          class="share-btn share-linkedin"
          aria-label="링크드인에 공유"
          title="링크드인에 공유"
        >
          <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
            <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
          </svg>
        </a>
        <button
          type="button"
          class="share-btn share-copy"
          id="copy-link-btn"
          aria-label="링크 복사"
          title="링크 복사"
        >
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
          </svg>
        </button>
        <div class="copy-tooltip" id="copy-tooltip">링크가 복사되었습니다!</div>
      </div>
    </header>

    {imageObj && <img src={imageObj.url} alt={imageObj.alt} class="post-hero-image" />}

    <!-- 목차 (ToC) - JS로 자동 생성 -->
    <nav class="toc" id="toc"></nav>

    <!-- 상단 광고 슬롯 -->
    <AdSlot position="top" />

    <div class="post-content" id="post-content">
      <slot />
    </div>

    <!-- 쿠팡 추천 상품 -->
    {coupangLinks && coupangLinks.length > 0 && (
      <CoupangBanner links={coupangLinks} />
    )}

    <!-- 관련 글 추천 -->
    {currentSlug && (
      <RelatedPosts currentSlug={currentSlug} category={category} tags={tags} />
    )}

    <!-- Newsletter CTA -->
    <NewsletterCTA />

    <!-- Post Navigation (Prev/Next) -->
    {(prevPost || nextPost) && (
      <nav class="post-navigation">
        <div class="post-nav-grid">
          {prevPost && (
            <a href={`/blog/${prevPost.slug}/`} class="post-nav-link prev">
              <span class="post-nav-label">&larr; 이전 글</span>
              <span class="post-nav-title">{prevPost.title}</span>
            </a>
          )}
          {nextPost && (
            <a href={`/blog/${nextPost.slug}/`} class="post-nav-link next">
              <span class="post-nav-label">다음 글 &rarr;</span>
              <span class="post-nav-title">{nextPost.title}</span>
            </a>
          )}
        </div>
      </nav>
    )}

    <!-- 추천 버튼 -->
    <div class="like-section">
      <button class="like-btn" id="like-btn" aria-label="추천">
        <span class="like-icon" id="like-icon">&#9825;</span>
        <span class="like-count" id="like-count">0</span>
      </button>
      <span class="like-label">이 글이 도움이 되었나요?</span>
    </div>

    <!-- 관련 글 안내 -->
    <div class="post-cta">
      <h3>더 많은 글을 둘러보세요</h3>
      <p>더 많은 유용한 콘텐츠를 확인해보세요.</p>
      <div class="post-cta-buttons">
        <a href="/blog/" class="btn-primary">전체 글 보기</a>
        <a href={`/blog/${category.toLowerCase()}/`} class="btn-secondary">{catLabel} 더 보기</a>
      </div>
    </div>

    <!-- 하단 광고 슬롯 -->
    <AdSlot position="bottom" />

    <!-- AI 작성 안내 -->
    <aside class="ai-disclaimer">
      <p>이 글은 AI 기술을 활용하여 작성되었습니다. 핵심 정보와 데이터는 검증을 거쳤으나, 정확한 의사결정을 위해 공식 출처를 통한 추가 확인을 권장합니다.</p>
    </aside>

    <!-- 익명 댓글 시스템 -->
    <section class="comments-section" id="comments-section" data-slug={currentSlug} data-blog="lifeflow">
      <h3>댓글 <span class="comment-count" id="comment-count"></span></h3>

      <!-- 댓글 작성 폼 -->
      <form class="comment-form" id="comment-form">
        <div class="comment-form-row">
          <input type="text" id="comment-name" placeholder="이름 (선택, 미입력 시 '익명')" maxlength="20" class="comment-input" />
          <input type="password" id="comment-password" placeholder="삭제용 비밀번호 (필수)" maxlength="30" required class="comment-input" />
        </div>
        <textarea id="comment-content" placeholder="댓글을 입력하세요..." rows="3" maxlength="1000" required class="comment-textarea"></textarea>
        <div class="comment-form-footer">
          <span class="comment-char-count" id="comment-char-count">0 / 1000</span>
          <button type="submit" class="comment-submit-btn" id="comment-submit-btn">댓글 등록</button>
        </div>
      </form>

      <!-- 댓글 목록 -->
      <div class="comment-list" id="comment-list">
        <p class="comment-loading" id="comment-loading">댓글을 불러오는 중...</p>
      </div>

      <!-- 삭제 모달 -->
      <div class="comment-modal-overlay" id="delete-modal" style="display:none;">
        <div class="comment-modal">
          <h4>댓글 삭제</h4>
          <p>작성 시 입력한 비밀번호를 입력하세요.</p>
          <input type="password" id="delete-password" placeholder="비밀번호" class="comment-input" />
          <div class="comment-modal-btns">
            <button type="button" class="comment-cancel-btn" id="delete-cancel">취소</button>
            <button type="button" class="comment-delete-btn" id="delete-confirm">삭제</button>
          </div>
          <p class="comment-error" id="delete-error" style="display:none;"></p>
        </div>
      </div>
    </section>
  </article>

  <script>
    // Copy link to clipboard
    (function() {
      const copyBtn = document.getElementById('copy-link-btn');
      const tooltip = document.getElementById('copy-tooltip');

      if (copyBtn && tooltip) {
        copyBtn.addEventListener('click', async () => {
          try {
            await navigator.clipboard.writeText(window.location.href);
            tooltip.classList.add('show');
            setTimeout(() => {
              tooltip.classList.remove('show');
            }, 2000);
          } catch (err) {
            console.error('Failed to copy:', err);
          }
        });
      }
    })();

    // Like button logic
    (function() {
      const likeBtn = document.getElementById('like-btn');
      const likeIcon = document.getElementById('like-icon');
      const likeCount = document.getElementById('like-count');
      if (!likeBtn || !likeIcon || !likeCount) return;

      const slug = window.location.pathname.replace(/^\/blog\//, '').replace(/\/$/, '');
      const storageKey = 'liked_' + slug;
      const countKey = 'like_count_' + slug;

      // Load state
      const isLiked = localStorage.getItem(storageKey) === 'true';
      let count = parseInt(localStorage.getItem(countKey) || '0', 10);

      function render() {
        likeCount.textContent = String(count);
        if (isLiked) {
          likeIcon.innerHTML = '&#9829;';
          likeBtn.classList.add('liked');
          likeBtn.disabled = true;
        }
      }
      render();

      likeBtn.addEventListener('click', () => {
        if (localStorage.getItem(storageKey) === 'true') return;
        localStorage.setItem(storageKey, 'true');
        count++;
        localStorage.setItem(countKey, String(count));
        likeIcon.innerHTML = '&#9829;';
        likeBtn.classList.add('liked');
        likeBtn.disabled = true;
        likeCount.textContent = String(count);

        // Animation
        likeBtn.classList.add('like-pop');
        setTimeout(() => likeBtn.classList.remove('like-pop'), 600);
      });
    })();

    // Auto-generate Table of Contents
    (function() {
      const content = document.getElementById('post-content');
      const toc = document.getElementById('toc');
      if (!content || !toc) return;

      const headings = content.querySelectorAll('h2, h3');
      if (headings.length < 2) { toc.style.display = 'none'; return; }

      let html = '<h4>목차</h4><ul>';
      headings.forEach((h, i) => {
        const id = 'heading-' + i;
        h.id = id;
        const indent = h.tagName === 'H3' ? ' class="toc-sub"' : '';
        html += `<li${indent}><a href="#${id}">${h.textContent}</a></li>`;
      });
      html += '</ul>';
      toc.innerHTML = html;

      // Estimate reading time
      const text = content.textContent || '';
      const minutes = Math.max(1, Math.round(text.length / 500));
      const readingEl = document.querySelector('.post-reading-time');
      if (readingEl) readingEl.textContent = `읽기 약 ${minutes}분`;

      // === Chart Rendering System (Enhanced) ===
      function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1,3), 16);
        const g = parseInt(hex.slice(3,5), 16);
        const b = parseInt(hex.slice(5,7), 16);
        return `rgba(${r},${g},${b},${alpha})`;
      }

      // IntersectionObserver for scroll animation
      const chartObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.querySelectorAll('.chart-fill, .radar-score-fill, .versus-fill').forEach(fill => {
              fill.classList.add('animated');
            });
            entry.target.querySelectorAll('.progress-ring').forEach(ring => {
              ring.style.strokeDashoffset = ring.dataset.target;
            });
            chartObserver.unobserve(entry.target);
          }
        });
      }, { threshold: 0.2 });

      // 1) Render bar charts
      document.querySelectorAll('.chart-bar').forEach(el => {
        const labels = (el.dataset.labels || '').split(',');
        const values = (el.dataset.values || '').split(',').map(Number);
        const colors = (el.dataset.colors || '#3b82f6,#f59e0b,#10b981,#ef4444,#8b5cf6').split(',');
        const title = el.dataset.title || '';
        const unit = el.dataset.unit || '';
        const max = Math.max(...values) * 1.15;

        let html = '';
        if (title) html += `<div class="chart-title">${title}</div>`;
        html += '<div class="chart-bars">';
        labels.forEach((label, i) => {
          const pct = max > 0 ? (values[i] / max) * 100 : 0;
          const color = colors[i % colors.length].trim();
          const grad = `linear-gradient(90deg, ${color}, ${hexToRgba(color, 0.7)})`;
          html += `<div class="chart-row">
            <span class="chart-label">${label.trim()}</span>
            <div class="chart-track">
              <div class="chart-fill" style="width:${pct}%;background:${grad}">
                ${pct > 25 ? `<span class="chart-fill-inner-val">${values[i]}${unit}</span>` : ''}
              </div>
            </div>
            <span class="chart-value">${values[i]}${unit}</span>
          </div>`;
        });
        html += '</div>';
        el.innerHTML = html;
        chartObserver.observe(el);
      });

      // 2) Render radar/score charts
      document.querySelectorAll('.chart-radar').forEach(el => {
        const items = JSON.parse(el.dataset.items || '[]');
        const title = el.dataset.title || '';
        let html = '';
        if (title) html += `<div class="chart-title">${title}</div>`;
        html += '<div class="chart-radar-grid">';
        items.forEach(item => {
          const scores = item.scores || [];
          const avg = scores.length > 0 ? (scores.reduce((a,s) => a + s.value, 0) / scores.length).toFixed(1) : '0';
          const mainColor = scores[0]?.color || '#3b82f6';
          html += `<div class="radar-item">
            <div class="radar-item-accent" style="background:${mainColor}"></div>
            <div class="radar-name" style="color:${mainColor}">${item.name}</div>
            <div class="radar-avg">
              <span class="radar-avg-badge" style="background:${hexToRgba(mainColor, 0.12)};color:${mainColor}">
                평균 ${avg}/10
              </span>
            </div>
            <div class="radar-scores">`;
          scores.forEach(s => {
            const pct = (s.value / 10) * 100;
            const grad = `linear-gradient(90deg, ${s.color || '#3b82f6'}, ${hexToRgba(s.color || '#3b82f6', 0.6)})`;
            html += `<div class="radar-score-row">
              <span class="radar-score-label">${s.label}</span>
              <div class="radar-score-track">
                <div class="radar-score-fill" style="width:${pct}%;background:${grad}"></div>
              </div>
              <span class="radar-score-val" style="color:${s.color || '#3b82f6'}">${s.value}</span>
            </div>`;
          });
          html += '</div></div>';
        });
        html += '</div>';
        el.innerHTML = html;
        chartObserver.observe(el);
      });

      // 3) Render donut charts
      document.querySelectorAll('.chart-donut').forEach(el => {
        const labels = (el.dataset.labels || '').split(',');
        const values = (el.dataset.values || '').split(',').map(Number);
        const colors = (el.dataset.colors || '#3b82f6,#10b981,#f59e0b,#ef4444,#8b5cf6').split(',');
        const title = el.dataset.title || '';
        const unit = el.dataset.unit || '';
        const total = values.reduce((a, v) => a + v, 0);

        let gradient = '';
        let cumPct = 0;
        values.forEach((v, i) => {
          const pct = total > 0 ? (v / total) * 100 : 0;
          const color = colors[i % colors.length].trim();
          gradient += `${color} ${cumPct}% ${cumPct + pct}%`;
          cumPct += pct;
          if (i < values.length - 1) gradient += ', ';
        });

        let html = '';
        if (title) html += `<div class="chart-title">${title}</div>`;
        html += '<div class="chart-donut-container">';
        html += `<div class="donut-ring" style="background:conic-gradient(${gradient})">`;
        html += `<div class="donut-hole"><span class="donut-total">${total}${unit}</span><span class="donut-total-label">합계</span></div>`;
        html += '</div>';
        html += '<div class="donut-legend">';
        labels.forEach((label, i) => {
          const pct = total > 0 ? ((values[i] / total) * 100).toFixed(1) : '0';
          html += `<div class="donut-legend-item">
            <span class="donut-legend-dot" style="background:${colors[i % colors.length].trim()}"></span>
            <span class="donut-legend-label">${label.trim()}</span>
            <span class="donut-legend-value">${values[i]}${unit} (${pct}%)</span>
          </div>`;
        });
        html += '</div></div>';
        el.innerHTML = html;
      });

      // 4) Render versus charts
      document.querySelectorAll('.chart-versus').forEach(el => {
        const items = JSON.parse(el.dataset.items || '[]');
        const title = el.dataset.title || '';
        const nameA = el.dataset.nameA || 'A';
        const nameB = el.dataset.nameB || 'B';
        const colorA = el.dataset.colorA || '#3b82f6';
        const colorB = el.dataset.colorB || '#10b981';
        const maxVal = Math.max(...items.flatMap(i => [i.a, i.b])) * 1.1;

        let html = '';
        if (title) html += `<div class="chart-title">${title}</div>`;
        html += `<div class="versus-header">
          <span class="versus-name" style="color:${colorA}">${nameA}</span>
          <span class="versus-vs">VS</span>
          <span class="versus-name" style="color:${colorB}">${nameB}</span>
        </div>`;
        html += '<div class="versus-rows">';
        items.forEach(item => {
          const pctA = maxVal > 0 ? (item.a / maxVal) * 100 : 0;
          const pctB = maxVal > 0 ? (item.b / maxVal) * 100 : 0;
          html += `<div class="versus-row">
            <div class="versus-bar-left">
              <span class="versus-val">${item.a}</span>
              <div class="versus-track versus-track-left">
                <div class="versus-fill" style="width:${pctA}%;background:linear-gradient(270deg, ${colorA}, ${hexToRgba(colorA, 0.6)})"></div>
              </div>
            </div>
            <div class="versus-label">${item.label}</div>
            <div class="versus-bar-right">
              <div class="versus-track">
                <div class="versus-fill" style="width:${pctB}%;background:linear-gradient(90deg, ${colorB}, ${hexToRgba(colorB, 0.6)})"></div>
              </div>
              <span class="versus-val">${item.b}</span>
            </div>
          </div>`;
        });
        html += '</div>';
        el.innerHTML = html;
        chartObserver.observe(el);
      });

      // 5) Render progress circle charts
      document.querySelectorAll('.chart-progress').forEach(el => {
        const labels = (el.dataset.labels || '').split(',');
        const values = (el.dataset.values || '').split(',').map(Number);
        const colors = (el.dataset.colors || '#3b82f6,#10b981,#f59e0b,#ef4444,#8b5cf6').split(',');
        const title = el.dataset.title || '';
        const max = Number(el.dataset.max || '100');
        const unit = el.dataset.unit || '';
        const circumference = 2 * Math.PI * 45;

        let html = '';
        if (title) html += `<div class="chart-title">${title}</div>`;
        html += '<div class="progress-grid">';
        labels.forEach((label, i) => {
          const pct = Math.min(values[i] / max, 1);
          const offset = circumference - (circumference * pct);
          const color = colors[i % colors.length].trim();
          html += `<div class="progress-item">
            <div class="progress-circle">
              <svg viewBox="0 0 100 100">
                <circle class="progress-bg" cx="50" cy="50" r="45" />
                <circle class="progress-ring" cx="50" cy="50" r="45"
                  style="stroke:${color};stroke-dasharray:${circumference};stroke-dashoffset:${circumference}"
                  data-target="${offset}" />
              </svg>
              <div class="progress-value" style="color:${color}">${values[i]}${unit}</div>
            </div>
            <div class="progress-label">${label.trim()}</div>
          </div>`;
        });
        html += '</div>';
        el.innerHTML = html;
        chartObserver.observe(el);
      });
    })();

    // ===== Code Copy Button =====
    (function() {
      const content = document.getElementById('post-content');
      if (!content) return;
      content.querySelectorAll('pre').forEach(pre => {
        if (pre.parentElement.classList.contains('code-block-wrapper')) return;
        const wrapper = document.createElement('div');
        wrapper.className = 'code-block-wrapper';
        pre.parentNode.insertBefore(wrapper, pre);
        wrapper.appendChild(pre);
        const btn = document.createElement('button');
        btn.className = 'code-copy-btn';
        btn.textContent = '복사';
        btn.addEventListener('click', async () => {
          const code = pre.querySelector('code') || pre;
          try {
            await navigator.clipboard.writeText(code.textContent);
            btn.textContent = '복사됨!';
            btn.classList.add('copied');
            setTimeout(() => { btn.textContent = '복사'; btn.classList.remove('copied'); }, 2000);
          } catch(e) { btn.textContent = '실패'; }
        });
        wrapper.appendChild(btn);
      });
    })();

    // ===== ToC Scroll Highlight =====
    (function() {
      const toc = document.getElementById('toc');
      const content = document.getElementById('post-content');
      if (!toc || !content) return;
      const headings = content.querySelectorAll('h2[id], h3[id]');
      if (headings.length < 2) return;
      const tocLinks = toc.querySelectorAll('a');
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            tocLinks.forEach(a => a.classList.remove('toc-active'));
            const active = toc.querySelector(`a[href="#${entry.target.id}"]`);
            if (active) active.classList.add('toc-active');
          }
        });
      }, { rootMargin: '-80px 0px -70% 0px', threshold: 0 });
      headings.forEach(h => observer.observe(h));
    })();

    // ===== Accordion FAQ =====
    (function() {
      const content = document.getElementById('post-content');
      if (!content) return;
      const faqHeading = Array.from(content.querySelectorAll('h2')).find(
        h => h.textContent.includes('자주 묻는 질문') || h.textContent.includes('FAQ')
      );
      if (!faqHeading) return;
      const items = [];
      let el = faqHeading.nextElementSibling;
      let currentQ = null;
      let currentA = [];
      while (el && el.tagName !== 'H2') {
        if (el.tagName === 'H3') {
          if (currentQ) items.push({ q: currentQ, a: currentA.join('') });
          currentQ = el.textContent.replace(/^Q\d*[\.\:]\s*/, '').replace(/^\d+\.\s*/, '');
          currentA = [];
        } else if (currentQ) {
          currentA.push(el.outerHTML);
        }
        el = el.nextElementSibling;
      }
      if (currentQ) items.push({ q: currentQ, a: currentA.join('') });
      if (items.length === 0) return;
      const container = document.createElement('div');
      container.className = 'faq-accordion';
      items.forEach(item => {
        const details = document.createElement('details');
        details.className = 'faq-item';
        details.innerHTML = `<summary>${item.q}</summary><div class="faq-answer">${item.a}</div>`;
        container.appendChild(details);
      });
      let removeEl = faqHeading.nextElementSibling;
      while (removeEl && removeEl.tagName !== 'H2') {
        const next = removeEl.nextElementSibling;
        removeEl.remove();
        removeEl = next;
      }
      faqHeading.after(container);
    })();

    // ===== Difficulty Badge (auto-detect) =====
    (function() {
      const content = document.getElementById('post-content');
      const meta = document.querySelector('.post-meta');
      if (!content || !meta) return;
      const text = content.textContent || '';
      const codeBlocks = content.querySelectorAll('pre code').length;
      const length = text.length;
      let level = 'beginner';
      let label = '초급';
      let icon = '\uD83D\uDFE2';
      if (length > 8000 || codeBlocks > 5) {
        level = 'advanced'; label = '고급'; icon = '\uD83D\uDD34';
      } else if (length > 4000 || codeBlocks > 2) {
        level = 'intermediate'; label = '중급'; icon = '\uD83D\uDFE1';
      }
      const badge = document.createElement('span');
      badge.className = `difficulty-badge ${level}`;
      badge.textContent = `${icon} ${label}`;
      meta.appendChild(badge);
    })();

    // ===== Anonymous Comment System =====
    (function() {
      const SUPABASE_URL = 'https://xyprbsmagtlzebxyxsvj.supabase.co';
      const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inh5cHJic21hZ3RsemVieHl4c3ZqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA0NjY4NTQsImV4cCI6MjA4NjA0Mjg1NH0.dajN0n0IWzOgYOSCglxVLzddg7jJFRHNCHwTWMG62uU';
      const RPC = `${SUPABASE_URL}/rest/v1/rpc`;
      const headers = { 'apikey': SUPABASE_KEY, 'Authorization': `Bearer ${SUPABASE_KEY}`, 'Content-Type': 'application/json' };

      const section = document.getElementById('comments-section');
      if (!section) return;
      const postSlug = section.dataset.slug || '';
      const blogSource = section.dataset.blog || 'lifeflow';

      // Admin mode: localhost access
      const isAdmin = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';

      const form = document.getElementById('comment-form');
      const nameInput = document.getElementById('comment-name');
      const pwInput = document.getElementById('comment-password');
      const contentInput = document.getElementById('comment-content');
      const charCount = document.getElementById('comment-char-count');
      const submitBtn = document.getElementById('comment-submit-btn');
      const listEl = document.getElementById('comment-list');
      const loadingEl = document.getElementById('comment-loading');
      const countEl = document.getElementById('comment-count');

      const modal = document.getElementById('delete-modal');
      const deletePwInput = document.getElementById('delete-password');
      const deleteConfirm = document.getElementById('delete-confirm');
      const deleteCancel = document.getElementById('delete-cancel');
      const deleteError = document.getElementById('delete-error');
      let deleteTargetId = null;

      if (contentInput && charCount) {
        contentInput.addEventListener('input', () => {
          charCount.textContent = `${contentInput.value.length} / 1000`;
        });
      }

      function timeAgo(dateStr) {
        const now = new Date();
        const d = new Date(dateStr);
        const diff = Math.floor((now - d) / 1000);
        if (diff < 60) return '방금 전';
        if (diff < 3600) return `${Math.floor(diff / 60)}분 전`;
        if (diff < 86400) return `${Math.floor(diff / 3600)}시간 전`;
        if (diff < 2592000) return `${Math.floor(diff / 86400)}일 전`;
        return d.toLocaleDateString('ko-KR', { year: 'numeric', month: 'short', day: 'numeric' });
      }

      function esc(str) {
        const d = document.createElement('div');
        d.textContent = str;
        return d.innerHTML;
      }

      // Toggle comment visibility (admin only)
      async function toggleHide(commentId) {
        try {
          const res = await fetch(`${RPC}/toggle_comment_visibility`, {
            method: 'POST', headers,
            body: JSON.stringify({ p_comment_id: commentId })
          });
          const result = await res.json();
          if (result.success) {
            await loadComments();
          } else {
            alert(result.message || '처리에 실패했습니다.');
          }
        } catch (err) {
          alert('처리 중 오류가 발생했습니다.');
        }
      }

      // Render a single comment HTML
      function renderComment(c, depth) {
        const isHidden = c.is_hidden;
        const hiddenClass = isHidden ? ' comment-hidden' : '';
        const depthClass = depth > 0 ? ' comment-reply' : '';
        const depthStyle = depth > 0 ? ` style="margin-left:${Math.min(depth, 5) * 1.5}rem"` : '';
        const hideBtn = isAdmin
          ? `<button type="button" class="comment-hide-btn${isHidden ? ' unhide' : ''}" data-id="${c.id}" title="${isHidden ? '보이기' : '감추기'}">${isHidden ? '&#128065;' : '&#128064;'}</button>`
          : '';
        const delBtn = isAdmin || !isHidden
          ? `<button type="button" class="comment-del-btn" data-id="${c.id}" title="삭제">&#10005;</button>`
          : '';
        const replyBtn = !isHidden
          ? `<button type="button" class="comment-reply-btn" data-id="${c.id}">답글</button>`
          : '';

        const bodyContent = isHidden && !isAdmin
          ? '<span class="comment-masked">관리자에 의해 숨겨진 댓글입니다.</span>'
          : esc(c.content).replace(/\n/g, '<br>');
        const authorDisplay = isHidden && !isAdmin ? '' : `<span class="comment-author">${esc(c.author_name)}</span>`;
        const dateDisplay = isHidden && !isAdmin ? '' : `<span class="comment-date">${timeAgo(c.created_at)}</span>`;

        return `<div class="comment-item${hiddenClass}${depthClass}" data-id="${c.id}"${depthStyle}>
          <div class="comment-header">
            ${authorDisplay}
            ${dateDisplay}
            ${replyBtn}
            ${hideBtn}
            ${delBtn}
          </div>
          <div class="comment-body">${bodyContent}</div>
        </div>`;
      }

      // Recursive render: comment + all descendants
      function renderTree(commentId, repliesMap, depth) {
        let html = '';
        if (repliesMap[commentId]) {
          repliesMap[commentId].forEach(child => {
            html += renderComment(child, depth);
            html += renderTree(child.id, repliesMap, depth + 1);
          });
        }
        return html;
      }

      // Show inline reply form
      function showReplyForm(parentId) {
        const existing = document.querySelector('.reply-form');
        if (existing) existing.remove();

        const parentEl = listEl.querySelector(`.comment-item[data-id="${parentId}"]`);
        if (!parentEl) return;

        const replyHtml = `<div class="reply-form" data-parent="${parentId}">
          <div class="comment-form-row">
            <input type="text" class="reply-name comment-input" placeholder="이름 (선택)" maxlength="20" />
            <input type="password" class="reply-password comment-input" placeholder="삭제용 비밀번호" maxlength="30" required />
          </div>
          <textarea class="reply-content comment-textarea" placeholder="답글을 입력하세요..." rows="2" maxlength="500" required></textarea>
          <div class="comment-form-footer">
            <button type="button" class="reply-cancel-btn">취소</button>
            <button type="button" class="reply-submit-btn">답글 등록</button>
          </div>
        </div>`;
        parentEl.insertAdjacentHTML('afterend', replyHtml);

        const formEl = document.querySelector('.reply-form');
        formEl.querySelector('.reply-cancel-btn').addEventListener('click', () => formEl.remove());
        formEl.querySelector('.reply-submit-btn').addEventListener('click', async () => {
          const name = formEl.querySelector('.reply-name').value.trim();
          const pw = formEl.querySelector('.reply-password').value;
          const content = formEl.querySelector('.reply-content').value.trim();
          if (!content || !pw) return;

          const btn = formEl.querySelector('.reply-submit-btn');
          btn.disabled = true;
          btn.textContent = '등록 중...';

          try {
            const res = await fetch(`${RPC}/add_comment`, {
              method: 'POST', headers,
              body: JSON.stringify({
                p_post_slug: postSlug, p_blog_source: blogSource,
                p_author_name: name || '익명', p_content: content,
                p_password: pw, p_parent_id: parentId
              })
            });
            const result = await res.json();
            if (result.success) {
              formEl.remove();
              await loadComments();
            } else {
              alert(result.message || '답글 등록에 실패했습니다.');
              btn.disabled = false;
              btn.textContent = '답글 등록';
            }
          } catch (err) {
            alert('답글 등록 중 오류가 발생했습니다.');
            btn.disabled = false;
            btn.textContent = '답글 등록';
          }
        });

        formEl.querySelector('.reply-content').focus();
      }

      async function loadComments() {
        try {
          const body = { p_post_slug: postSlug, p_blog_source: blogSource, p_include_hidden: true };

          const res = await fetch(`${RPC}/get_comments`, {
            method: 'POST', headers,
            body: JSON.stringify(body)
          });
          const data = await res.json();
          if (loadingEl) loadingEl.style.display = 'none';

          if (!Array.isArray(data) || data.length === 0) {
            listEl.innerHTML = '<p class="comment-empty">아직 댓글이 없습니다. 첫 번째 댓글을 남겨보세요!</p>';
            if (countEl) countEl.textContent = '';
            return;
          }

          if (countEl) countEl.textContent = `(${data.length})`;

          // Group into tree: root comments + replies
          const roots = data.filter(c => !c.parent_id);
          const repliesMap = {};
          data.filter(c => c.parent_id).forEach(c => {
            if (!repliesMap[c.parent_id]) repliesMap[c.parent_id] = [];
            repliesMap[c.parent_id].push(c);
          });

          let html = '';
          roots.forEach(c => {
            html += renderComment(c, 0);
            html += renderTree(c.id, repliesMap, 1);
          });
          listEl.innerHTML = html;

          listEl.querySelectorAll('.comment-del-btn').forEach(btn => {
            btn.addEventListener('click', () => openDeleteModal(Number(btn.dataset.id)));
          });

          if (isAdmin) {
            listEl.querySelectorAll('.comment-hide-btn').forEach(btn => {
              btn.addEventListener('click', () => toggleHide(Number(btn.dataset.id)));
            });
          }

          listEl.querySelectorAll('.comment-reply-btn').forEach(btn => {
            btn.addEventListener('click', () => showReplyForm(Number(btn.dataset.id)));
          });
        } catch (e) {
          if (loadingEl) loadingEl.textContent = '댓글을 불러올 수 없습니다.';
        }
      }

      if (form) {
        form.addEventListener('submit', async (e) => {
          e.preventDefault();
          const name = nameInput.value.trim();
          const pw = pwInput.value;
          const content = contentInput.value.trim();
          if (!content || !pw) return;

          submitBtn.disabled = true;
          submitBtn.textContent = '등록 중...';

          try {
            const res = await fetch(`${RPC}/add_comment`, {
              method: 'POST', headers,
              body: JSON.stringify({
                p_post_slug: postSlug,
                p_blog_source: blogSource,
                p_author_name: name || '익명',
                p_content: content,
                p_password: pw
              })
            });
            const result = await res.json();
            if (result.success) {
              contentInput.value = '';
              pwInput.value = '';
              nameInput.value = '';
              if (charCount) charCount.textContent = '0 / 1000';
              await loadComments();
            } else {
              alert(result.message || '댓글 등록에 실패했습니다.');
            }
          } catch (err) {
            alert('댓글 등록 중 오류가 발생했습니다.');
          }
          submitBtn.disabled = false;
          submitBtn.textContent = '댓글 등록';
        });
      }

      function openDeleteModal(id) {
        deleteTargetId = id;
        modal.style.display = 'flex';
        deletePwInput.value = '';
        deleteError.style.display = 'none';
        deletePwInput.focus();
      }

      if (deleteCancel) {
        deleteCancel.addEventListener('click', () => {
          modal.style.display = 'none';
          deleteTargetId = null;
        });
      }

      if (modal) {
        modal.addEventListener('click', (e) => {
          if (e.target === modal) { modal.style.display = 'none'; deleteTargetId = null; }
        });
      }

      if (deleteConfirm) {
        deleteConfirm.addEventListener('click', async () => {
          const pw = deletePwInput.value;
          if (!pw || deleteTargetId === null) return;

          deleteConfirm.disabled = true;
          deleteConfirm.textContent = '삭제 중...';

          try {
            const res = await fetch(`${RPC}/delete_comment`, {
              method: 'POST', headers,
              body: JSON.stringify({ p_comment_id: deleteTargetId, p_password: pw })
            });
            const result = await res.json();
            if (result.success) {
              modal.style.display = 'none';
              deleteTargetId = null;
              await loadComments();
            } else {
              deleteError.textContent = result.message || '삭제에 실패했습니다.';
              deleteError.style.display = 'block';
            }
          } catch (err) {
            deleteError.textContent = '삭제 중 오류가 발생했습니다.';
            deleteError.style.display = 'block';
          }
          deleteConfirm.disabled = false;
          deleteConfirm.textContent = '삭제';
        });
      }

      loadComments();
    })();
  </script>
</BaseLayout>
